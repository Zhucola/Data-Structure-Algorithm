## 排序
* [冒泡排序]
* [选择排序]
* [插入排序]
* [归并排序]
* [快速排序]
* [堆排序]

||冒泡|优化冒泡|选择|优化选择|插入|归并|快排|堆排序|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|100|0.00023|0.000277|0.000098|0.000082|0.000104|0.000192|0.00014|0.00019|
|1000|0.02423|0.02597|0.01434|0.0127|0.01208|0.0026|0.0006|0.00308|
|10000|2.3718|2.3178|1.0359|0.8146|0.8587|0.0222|0.01236|0.03449|
|50000|61.638|59.470|25.337|20.426|21.491|0.1248|0.09279|0.22093|
|100000|244.389|236.38|101.58|81.64|86.95|0.267|0.3982|0.4647|

|topK找最大前100个|堆排序|
|:---|:---|
|100000|0.0327|

## 查找
* [二分查找]
* [二叉树查找]
## 数据结构
* [单向链表]
  * 向链表头添加元素
  * 向链表尾部添加新节点
  * 删除链表头元素
  * 判断链表是否为空
  * 遍历链表
  * 向链表中的指定位置插入元素
  * 删除链表中的指定位置
  * 不知道节点总个数,找到单链表中间节点
  * 找到环的入口
  * 求环的长度
  * 判断是否有环
  * 删除排序链表中的重复元素
  * 在两个链表无环的情况环判断是否相交
  * 在两个链表有环的情况环判断是否相交
  * 找到两个有交点的链表的交点
  * 链表翻转
  * 在不知道链表长度的情况下，查出倒数第N个节点
  * 合并两个有序的单链表
  * 删除一个给定的节点，该节点在链表中，时间复杂度O(1)
* [双向链表]
* [二叉堆]
* [搜索二叉树]
  * 添加值
  * 获取key对应的值
  * 获取最小key对应的值
  * 翻转
  * 合并两个二叉树
  * 查找排名为第N个的键的值
  * 求高度
  * 遍历(前、中、后序)
  * 删除最小键
  * 删除一个给定的key对应的节点
  * 判断是否是完全二叉树
  * 判断是否是满二叉树
* [搜索二叉树]
  * 添加值
  * 获取key对应的值
  * 获取最小key对应的值
  * 翻转
  * 合并两个二叉树
  * 查找排名为第N个的键的值
  * 求高度
  * 遍历(前、中、后序)
  * 删除最小键
  * 删除一个给定的key对应的节点
  * 判断是否是完全二叉树
  * 判断是否是满二叉树
